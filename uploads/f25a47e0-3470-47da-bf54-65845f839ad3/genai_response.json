{
  "problemStatement": "You are tasked with simulating the operation of a single-core processor. This processor handles a series of computational tasks. Each task has an `arrival_time` (the moment it becomes available) and a `processing_duration` (the time it takes for the processor to complete it). You need to determine the *completion time* for each task.\n\nWhen a task arrives, it is immediately placed at the back of a waiting queue. The processor strictly follows a First-In, First-Out (FIFO) policy, meaning it always takes the task that has been in the queue the longest.\n\nThe processor operates under these rules:\n1. If the processor is idle and the waiting queue is not empty, it immediately starts processing the task at the front of the queue.\n2. If a task finishes processing and the waiting queue is not empty, the processor immediately takes the next task from the front of the queue.\n3. If a task finishes processing and the waiting queue is empty, the processor becomes idle.\n4. Tasks are provided to you in non-decreasing order of their arrival times.\n\nYour objective is to determine the *completion time* for each task. The completion time for a task is the exact moment it finishes execution.",
  "inputFormat": "The first line contains an integer `T`, the number of testcases.\n\nFor each testcase:\nThe first line contains an integer `N`, the number of tasks.\nThe next `N` lines each contain two space-separated integers, `arrival_time_i` and `processing_duration_i`, for the i-th task.",
  "outputFormat": "For each testcase, output `N` lines. Each line should contain a single integer: the completion time for the i-th task (in the order they were provided in the input).",
  "constraints": "- `1 <= T <= 100`\n- `1 <= N <= 10^5`\n- `0 <= arrival_time_i <= 10^9`\n- `1 <= processing_duration_i <= 10^4`\n- `arrival_time_i <= arrival_time_{i+1}` for all `0 <= i < N-1`.\n- The sum of `N` over all testcases does not exceed `2 * 10^5`.",
  "sampleInput": "2\n3\n0 5\n2 3\n7 2\n4\n10 4\n12 6\n15 2\n18 3",
  "sampleOutput": "5\n8\n10\n14\n20\n22\n25",
  "solution": "import sys\nfrom collections import deque\n\ndef solve():\n    N = int(sys.stdin.readline())\n    all_tasks = []\n    for _ in range(N):\n        arrival_time, duration = map(int, sys.stdin.readline().split())\n        all_tasks.append((arrival_time, duration))\n\n    current_time = 0  # Represents the current simulation time\n    task_queue = deque()  # Stores (duration, original_index) of tasks waiting to be processed\n    results = [0] * N  # To store completion times for each task\n    task_pointer = 0  # Pointer to the next incoming task from all_tasks\n\n    # Loop continues as long as there are tasks to be processed or tasks yet to arrive\n    while task_pointer < N or task_queue:\n        # 1. Add all tasks that have arrived by `current_time` to the queue.\n        # This ensures tasks are enqueued as soon as they become available.\n        while task_pointer < N and all_tasks[task_pointer][0] <= current_time:\n            _, duration = all_tasks[task_pointer]\n            task_queue.append((duration, task_pointer))\n            task_pointer += 1\n\n        # 2. If the processor is idle and the queue is not empty, process the next task.\n        if task_queue:\n            duration, original_idx = task_queue.popleft()\n            # The task starts processing at `current_time` and finishes after its `duration`.\n            completion_time = current_time + duration\n            results[original_idx] = completion_time\n            current_time = completion_time  # Processor becomes free at this new `current_time`\n        else:\n            # Processor is idle, and the queue is empty.\n            # Advance `current_time` to the arrival time of the next task.\n            # This handles periods where the processor is waiting for new tasks.\n            if task_pointer < N:\n                current_time = all_tasks[task_pointer][0]\n            else:\n                # All tasks have been processed, and no more tasks are arriving.\n                # The simulation is complete.\n                break\n\n    for res in results:\n        sys.stdout.write(str(res) + \"\\n\")\n\nT = int(sys.stdin.readline())\nfor _ in range(T):\n    solve()\n"
}