{
  "problemStatement": "You are given a list of `N` students, each possessing a distinct skill level. Your task is to divide these students into exactly `K` teams. The \"cohesion\" of a team is defined as the difference between the highest and lowest skill levels among its members. For instance, a team with skills `[10, 12, 15]` has a cohesion of `15 - 10 = 5`. \n\nYour objective is to partition all `N` students into `K` teams such that the *maximum* cohesion among all `K` teams is minimized. What is this minimum possible maximum cohesion?",
  "inputFormat": "The first line contains an integer `T` (the number of testcases).\n\nFor each testcase:\n- The first line contains two space-separated integers `N` and `K` (number of students and number of teams).\n- The second line contains `N` space-separated integers, `skill_1, skill_2, ..., skill_N`, representing the skill levels of the students.",
  "outputFormat": "For each testcase, print a single integer: the minimum possible maximum cohesion.",
  "constraints": "1 <= T <= 100\n1 <= K <= N <= 10^5\n0 <= skill_i <= 10^9\nThe sum of N over all testcases does not exceed 2 * 10^5.",
  "sampleInput": "2\n5 3\n10 20 30 40 50\n4 2\n1 10 100 1000",
  "sampleOutput": "10\n98",
  "solution": "import sys\n\ndef solve():\n    N, K = map(int, sys.stdin.readline().split())\n    skills = list(map(int, sys.stdin.readline().split()))\n    \n    # Sorting skills is crucial for the greedy approach in can_form\n    skills.sort()\n\n    # Helper function: Check if it's possible to partition students into at most K teams\n    # such that no team has a cohesion greater than max_cohesion.\n    # This function uses a greedy approach: always make the current team\n    # as large as possible while respecting max_cohesion, thereby minimizing\n    # the total number of teams formed.\n    def can_form(max_cohesion):\n        teams_needed = 0\n        i = 0\n        while i < N:\n            teams_needed += 1\n            current_team_min_skill = skills[i]\n            j = i + 1\n            # Expand the current team as much as possible, adding students\n            # whose skill difference from the current team's min skill\n            # does not exceed max_cohesion.\n            while j < N and skills[j] - current_team_min_skill <= max_cohesion:\n                j += 1\n            # All students from skills[i] to skills[j-1] are now in this team.\n            # The next team will start with skills[j].\n            i = j\n        \n        # If we need M teams with this max_cohesion, and M <= K, it's possible.\n        # If M < K, we can always split one of the existing teams (or any team)\n        # into more teams without increasing their maximum cohesion until we have exactly K teams.\n        # If M > K, then max_cohesion is too small.\n        return teams_needed <= K\n\n    # The search space for the minimum possible maximum cohesion:\n    # - Minimum possible value: 0 (if K=N, or all students have the same skill).\n    # - Maximum possible value: skills[-1] - skills[0] (if K=1, all students form one team).\n    low = 0\n    high = skills[-1] - skills[0] if N > 0 else 0 # N >= 1 is guaranteed by constraints\n    ans = high # Initialize with a worst-case possible answer, to be minimized\n\n    # Perform binary search on the answer (max_cohesion).\n    # We are looking for the smallest `mid` for which `can_form(mid)` is True.\n    while low <= high:\n        mid = low + (high - low) // 2\n        if can_form(mid):\n            ans = mid      # `mid` is a possible answer, try for a smaller one\n            high = mid - 1\n        else:\n            low = mid + 1  # `mid` is too small, need a larger `max_cohesion`\n    \n    sys.stdout.write(str(ans) + '\\n')\n\n# Read the number of testcases\nT = int(sys.stdin.readline())\nfor _ in range(T):\n    solve()\n"
}